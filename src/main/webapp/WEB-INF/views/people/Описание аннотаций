@Component - помечаем ей класс, если хотим что бы Спринг создал бин из этого класса
-Именно эту аннотацию сприн ищет, когда сканирует все ваши классы
-можно указать id для создаваемого бина, можно не указывать(тогда название будет название_класса_c_маленькой_буквы)
--------------------------------------------------
@Autowired - Аннотация для внедрения зависимостей, спринг ищет подходящий бин и автоматически внедряет его
-в нашем примере в бин musicPlayer необходимо внедрить бин, который реализует интерфейс Music*
-Спринг сканирует все классы с аннотацией @Component и создает бины для этих классов
-Спринг сканирует все созданные бины и проверяет, подходит ли хотя бы один бин в качестве зависимости там, где мы указали аннотацию @Autowired
-Если находится один подходящий бин, он внедряется в качестве зависимости
-Если не находится ни одного бина - ошибка
-Аннотация @Autowired подбирает подходящие бины по их типу(класс или интерфейс)
-Аннотацию @Autowired можно использовать на полях, сеттерах и конструкторах
--------------------------------------------------
@Qualifier - через данную аннотацию мы уточняем какой конкретно бин хотим внедрить!
- Указываем id того бина, который хотим внедрить!
- НЕОБЫЧНЫЙ СИНТАКСИС! - Когда внедрение производится с помощью КОНСТРУКТОРА, для уточнения зависимостей необходимо
использовать такой синтаксис: Аннотацию @Qualifier необходимо использовать рядом с аргументом конструктора!
--------------------------------------------------
@Value - Данная аннотация позволяет внедрять значение переменным
-Создаем файл пропертис -> передаем туда переменные со значением -> затем прописываем аннотацию над тем полем в котором хотим передать значение -> и в таким синтаксисом добавляем все @Value("${music.name}")
--------------------------------------------------
-@Scope - Область видимости бина
-По дефолту во всех бинах установлен бин "Синглтон"
-Синглтон - при каждом вызове метода getBean - будет возвращатся один и тот же обьект из spring application Context!
-Прототайп - При каждом вызове метода getBean - будет создаватся новый обьект в апликейшн контексте!
--------------------------------------------------
-Жизненный цикл бина!
-Запуск приложения -> Запускается спринг контроллер -> Создается обьект бина ->
В бин внедряются зависимости -> вызывается init-method -> Бин готов к использованию ->
работает приложение -> вызываестя указанный destroy-method -> Остановка Спринг приложения!
==================================================
@PostConstruct
init-method - запускается в ходе инициализации бина, инициализация ресурсов, обращение к внешним файлам, запуск БД.
==================================================
@PreDestroy
destroy-method - запускается в ходе уничтожения бина (при завершении приложения), очищение ресурсов, закрытие потоков ввода-вывода, закрытие доступа к БД.
==================================================
@ModelAttribute - Аннотация может аннотировать как метод, так и аргумент метода, в зависимости от того где указанна аннотация, она работает по разному.
-Когда аннотация аннотирует метод - это означает что в каждую модель мы хотим добавить какую-то пару ключ-значение.
-так же может добавлять в модель любой обьект.

-Когда аннотирует аргумент метода - она берет на себя 3 вещи(Создание обьекта, добавление значений в поля из хтмл формы и добавление этого обьекта/человека с полями в модель).
--------------------------------------------------
АННОТАЦИЯ @VALID (часть ее возможностей)
@Valid -
Для работы с валидатором нам нужно добавить еще одну зависимость в Pom файл - в maven repository -> Hibernate validator - берем файнал версию и добавляем в зависимости.
@NotEmpty - проверяет то, пустая ли строка, если да - выдает сообщение об ошибке!
@Size - диапазон строки который нас устраивает! @Size(min = 2, max = 30, message = "error") - если мы выйдем за одну из границ, то получим "message".
@Min - устанавливает минимальное значение для числового поля! @Min(value = 0, message = "error") - так мы указываем что хотим видеть числа только целые и пооложительные.
@Email - использует регулярные выражения и проверяет валидность мейла.
ХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХ
AOP - Его аннотации в коде*
@EnableAspectJAutoProxy - позволяет нам за кулисами использовать Spring AOP Proxy
-Что бы вынести бизнес логику и сквозную функциональность отдельно.
-Далее мы должны создать класс Aspect!
-@Aspect - говорит о том, что это не простой класс, а Aspect. Поэтому к данному классу СПринг будет относится по другому!
-Aspect - Это класс, отвечающий за сквозную функциональность!
Что бы использовать Аспект аннотацию, нужно добавить джар файл в среду разработки!
Что бы добавить джар файл - File -> Project Structure -> Libraries -> нажимаем плюс - указываем путь, нажимаем окей!
!!!!!!!!!!!!!!!!!!!!ТИПЫ ADVICE!!!!!!!!!!!!!!!!!!!
Before - выполняется до метода с основной логикой
After returning - выполняется только после нормального окончания метода с основной логикой
After throwing - выполняется после окончания метода с основной логикой только, если было выброшено исключение
After/After finally - выполняется после окончания метода с основной логикой
Around - выполняется до и после метода с основной логикой

Как выглядит запись с типами:
@Component
@Aspect
public class LoggingAspect{

@Before("execution(public void getBook())") - PointCut -это значит, что этот код должен сработать перед каким то методом, в нашем случае перед getBook()
public void beforeGetBookAdvice(){
    System.out.println("Попытка получить книгу");
}
}
Итоги!!!!!!
У нас есть какой то метод getBook, после чего мы создали Аспект класс, где и прописали функциональную логику до вызова основного метода.
Advice - метод, который находится в Aspect-e и содержит сквозную логику. Advice определяет, что и когда должно происходить.
В Идеале Advice должен быть небольшим и быстро работающим.
-Pointcut - выражение, описывающее где должен быть применен Advice.
-Spring AOP использует AspectJ Pointcut expression language. Т.е. определенные правила в написании выражений для использования Pointcut.

execution(public void get*()) - метод будет выполнен перед всеми методами начинающиеся на get!

execution(public void getBook(String)) - Соответствует методу с параметром String, где бы он ни находился с access midifier = public, return type = void и именем = getBook

execution(public void getBook(*)) - С любым одним параметром!

execution(public void getBook(..)) - С любым количеством любого типа параметров.

execution(public void getBook(aop.Book, ..)) - соответствует методу, первым параметром которого является aop.Book, а дальше параметров любого типа.

execution(* *(..)) - Соответствует методу с любым количеством любого типа параметров, где бы он ни находился с любыми правами доступа, любим ретерном и любым именем!

Объявление Pointcut!!!!!

Для того, чтобы не использовать копипаст когда для нескольких Advice-ов подходит один и тот же Pointcut, есть влзможность объявить данный Pointcut и затем использовать его несколько раз.
Объявление такого Адвайса!
@Pointcut("pointcut_expression")
private void pointcut_reference(){}


Испольвозание!
@Before("pointcut_reference()")
public void advice_name(){
some code
}

Плюсы объявления Pointcut:
-Возможность использования созданного Pointcut для множества Advice-ов
-Возможность быстрого изменения Поинткат значения для множества Адвайсов
-Возможность комбинирования Поинткатов
=================================================
Комбинирование Поинткатов!
Кобинирование поинткатов - это их объединение с помощью логических операторов && || !

Порядок выполнения Aspect-ов:
-Если при вызове 1-го метода с бизнес-логикой срабатывают несколько Адвайсов, то нет никакой гарантии в порядке выполнения этих адвайсов.
-Для соблюдения порядка такие адвайсы нужно распределять по отдельным упорядоченным аспектам.
@Order(2) упорядочивает Аспкты. Чем меньше число, тем выше приоритет.
=================================================
Join Point!!!!

Join Point - это точка/момент в выполняемой программе когда следует применять Advice. Т.е. это точка переплетения метода с бизнес-логикой и метода со служебным функционалом.
Прописав Joint Point в параметре метода Advice, мы получаем доступ к информации о сигнатуре и параметрах метода с бизнес-логикой.
ННННННННННННННННННННННННННННННННННННННННННННННННН
!!!!!!Hibernate!!!!!!
Hibernate - Это акфьуцщкл, который используется для сохранения, получения, изменени и удаления Java обьектов из БД

Плюсы Hibernate:
-Предоставляет технологию ORM
ORM(Object-Relation Mapping) - это преобразование обьекта в строку в таблице и обратное преобразование.
-Регулирует SQL запросы
-Уменьшает количество кода для написания
Hibernate использует JDBC для работы с базой данных.
hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
Hibernate:
Конфигурировать связь между классом и таблицей можно 2-мя способами:
-С помощью Xml файла - старый, не юзат
-С помощью Java аннотаций - новый!

--Entity класс - это java класс, который отображает информацию определенной таблицы в БД
--Entity класс - это POJO класс, в котором мы используем определенный Hibernate аннотации для связи класса с таблицей из базы.
--POJO(Plain Old Java Object) - класс, удовлетворяющий ряду условий: private поля, getter-ы и setter-ы, конструктор без аргументор и тд.
hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
@Entity - аннотация говорит о том, что данный класс будет иметь отображение в базе данных!
@Table - аннотация говорит о том, к какой именно таблице мы привязываем класс.
@Column - аннотация говорит о том, к какому именно сьолбцу из таблицы мы привязываем поле класса.
@Id -аннотация говорит о том, что в таблице, столбец связанный с данными полем является Primary Key.
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
JPA(Java Persistence API) - это стандартная спецификация, которая описывает систему для управления сохранением Java объектов в таблицк базы данных.
Hibernate - самая популярная реализация спецификации JPA.
Таким образом JPA описывает правила, а Hibernate реалтзует их.
SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
!!!!!!!!!!!!SessionFactory!!!!!!!!!!!!
SessionFactory - фабрика по производству сессий.
-SessionFactory читает файл hibernate.cfg.xml. После чего SessionFactory знает, как должны создаваться сессии.
-В Java приложении достаточно создать объект SessionFactory 1 раз и затем можно его переиспользовать.
-Session - это обертка вокруг подключения к базе с помощью JDBC:
    -Session мы получаем с помощью SessionFactory
    -Session - это основа для работы с Базой данных.
    Именно с помощью Session мы будем добавлять, получать и делать другие операции с Java Объектами
    в Базе Данных.
    -Жизненный цикл Session обычно не велик.
    Мы получаем Session, делаем с помощью нее
    определенные операции и она становится не нужной.
ХОХОХОХОХОХХОХОХОХХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХО
Что бы создать транзакциб для базы данных и добавить объект в нее нам нужно:
-Создать класс Employee - в котором будут прайвет поля, конструктор без аргументов и с аргументами(если нужно), геттеры и сеттеры!
-Помечаем класс аннотацией @Entity
-Так же помечаем класс аннотацией @Table - и в скобках указываем название таблицы в базе данных!
-поля помечаем аннотацией @Column - и в скобках передаем название столбца в который будет заходить данная информация!
-Так же помечаем столбец @Id - аннотация указывает первичный ключ, по которому будем обращаться к объекту*
-Затем создаем класс с мейном, где создаем SessionFactory(Смотреть в spring_course.test1.class), получаем с нее сессию, создаем объект с помощью джава кода, начинаем транзакцию, сохраняем объект, закрываем транзакцию через коммик либо роллБэк для отката на 1 транзакцию.
-оборачиваем на всякий случай в try и в finally просто закрываем все черех factory.close();
P.s. Важно, файл с конфигурацией БД хранить в папке resources
P.p.s. В дальнейшем не будет xml файла.
ХОХОХОХОХОХХОХОХОХХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХО
Primary Key!
-Столбец с Primary Key содержит уникальные значения и не может быть null.
-@GeneratedValue - аннотация описывает стратегию по генерации значений для столбца с Primary Key.
-GenerationType.IDENTITY - полагается на автоматическое увеличение столбца по правилам, прописанным в БД-х.
-GenerationType.SEQUENCE - полагается на работу Sequence, созданного в БД-х
-GenerationType.TABLE - полагается на значение столбца таблицы БД-х. Цель такой таблицы - поддержка уникальности значений.
-GenerationType.AUTO - дефолтный тип. Выбор стратегии будет зависить от типа базы, с которой мы работаем.
Пример использования  @GenerationValue:
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column
private int id;
ХОХОХОХОХОХХОХОХОХХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХО
Получение объекта из базы по ID:
int id = emp.getId(); - передали переменной id;
Session session = factory.getCurrentSession(); - создали новую сессию
session.beginTransaction(); - начали новую транзакцию
Employee myEmp = session.get(Employee.class, id); - с помощью get прописываем тип объекта который мы получаем и id
session.getTransaction().commit(); - закрываем сессию
System.out.println(emp); - выводим текущего юзера на экран, либо того, id которого мы указали.
ХОХОХОХОХОХХОХОХОХХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХО
ПОЛУЧЕНИЕ ОБЪЕКТОВ ИЗ БАЗЫ:
-Для получения объектов из базы используется HQL(Hibernate Query Language). HQL очень сход с SQL.
Session session = factory.getCurrentSession();
session.beginTransaction();

List<Employee> emps = session.createQuery("from Employee").getResultList();
for(Employee e: emps){
    System.out.println(e);
}
session.getTransaction().commit();
P.s. что бы получить обьект по конкретному значению, то смотрим в проекте(spring_course.Test3).
ХОХОХОХОХОХХОХОХОХХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХО
UPDATE ОБЪЕКТОВ:
Session session = factory.getCurrentSession();
session.beginTransaction();
Employee emp1 = session.get(Employee.class, 1);
emp1.setSalary(100);
session.getTransaction().commit();
-----------------------------------------------------
ДЛЯ НЕСКОЛЬКИХ СРАЗУ!
Session session = factory.getCurrentSession();
session.beginTransaction();
session.createQuery("update Employee set salary = 1000 where name = 'Elena'").executeUpdate();
session.getTransaction().commit();
-----------------------------------------------------
DELETE ОБЪЕКТОВ:

Session session = factory.getCurrentSession();
session.beginTransaction();
Employee emp1 = session.get(Employee.class, 1);
session.delete(emp1);
session.getTransaction().commit();
-----------------------------------------------------
ДЛЯ НЕСКОЛЬКИХ СРАЗУ:
Session session = factory.getCurrentSession();
session.beginTransaction();
session.createQuery("delete Employee where name = 'Lexa'").executeUpdate();
session.getTransaction().commit();
ХОХОХОХОХОХХОХОХОХХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХОХО
Типы отношений таблиц:
One-to-One(Один к одному)
{
School---Director
Employee---Details
}
One-to-Many(Один ко многим)
{
                ---Employee
Department }   ---Employee
                ---Employee
}
Many-to-One(Многие к одному)
{
Employee---
 Employee--- {Department
Employee---
}
Many-to-Many(Многие ко многим)