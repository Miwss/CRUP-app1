@Configuration - Помечает джава класс, который мы хотим использовать для конфигурации Спринг приложения!

Для каждого XML тега есть соответствующая аннотация

@ComponentScan("Название пакета") - по данной аннотации будет происходить скан всех классов в данном пакете!

@Bean - при использовании аннотации над методом, будет создан обьект(Бин)
================================
@Configuration
public class SpringConfig{
    return new ClassicalMusic();
}
================================
Для обращение к конфиг кллассу в методе мейн - мы используем запись
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
================================
Для внедрения значений из внешнего файла, без использования xml
 мы помечаем класс аннотацией @PropertySource("classpath: путь до файла"), затем через аннотацию @Value - передаем значение полям
================================

Что такое Spring MVC - Один из компонентов Спринг фреймворк - который позволяет разрабатывать веб - приложения на джава.
- СПРИНГ МВС - предполагает разработку  веб -приложений с использованием архитектуры Model - View - Controller.
- Разрабатывая веб - приложения с помощью Спринг МВС, мы можем использовать все, что дает нам Спринг Кор - бины, зависимости и так далее.

При http запросе мы попадаем в контроллер, после чего переходим в модел - где и происходит работа с данными, после чего модел возвращает на контроллер изменившиеся данные и передает их на вью пользователю

ХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХ
MVC - паттерн проектирования приложений!


Model - логика работы с данными!
View - логика представления, интерфейс!
Controller - логика навигации, обработка запросов!
{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
Контроллер(Controller) - Обрабатывает запросы от пользователся!
-Обменивается данными с моделью
-Показывает пользователю правлиьное представление
-Переадресовывает пользователся на другие страницы
=-сам контроллер реализуется нами!
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
Модель(Model) - Хранит в себе данные.
-Взаимодействует с БД для получения данных.
-Отдает данные контроллеру
=-саму модель реализуем сами!
{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
Представление(View) - Получает данные от контроллера и отображает их в браузере.
-Для динамического отобрадения данных используются шаблонизаторы(Thymeleaf, Freemarker, Velocity)
=-Само представление мы реализуем сами.
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
ХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХ

ИЗ ЧЕГО СОСТОИТ SPRING MVC ПРИЛОЖЕНИЕ?
-Из обычных Джава класснов(Контроллеры, модель, и прочее)
Очень активно используются аннотации, которые применяются к классам и дают им дополнительные возможности
(например, аннотация @Controller)
-Набор HTML страниц(представления). К ним часто добавляется JavaScript код, который "оживляет" HTML представления и CSS, котоырый использует ХТМЛ
-Спринг конфигурация(XML, Аннотации или Java)

ХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХХ

DispatcherServlet - он является входной точкой для нашего Spring MVC приложения.
-Он реализован за нас, так что нам его реализововать не нужно
-мы реализуем Модели, Представления и Контроллеры(MVC)


,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 HTTP запрос от пользователся:
 1)Риходит на сервер. Сервер обрабатывает запрос и передает его на Spring MVC приложение.
 2) Запрос попадает в DispatcherServlet.
 3) DispatcherServlet отправляет запрос на правильный контроллер.
XOXOXOOXOXOXOXOXOXOXOOXOXOXOXOOXOXOXOXOXOXOXOOX
 Конфигурация с помощью джава кода!
 -Мы уберем файлы web.xml и applicationContext.xml, заменив их на джава классы!
 В нашем примере, мы заменим файл web.xml - на класс MySpringMvcDispatcherServlet - который в свою очередь
 наследует класс AbstractAnnotationConfigDispatcherServletInitializer - внутри которого уже реализован интерфейс
 WebApplicationInitializer.
 Наследовавшись - мы оверрайдим 3 его мтеода, 2 из которых настраиваем, первый - не трогаем, второй - передаем класс конфигурации, тертий - возвращаем "/" - таким образом возвращаем все запросы на DispatcherServlet!
 ==============================================
 Затем создаем конфиг файл - в нашем случае SpringConfig,
 Помечаем его аннотацией @Configuration и @ComponentScan("Передаем путь пакета где лежит наш контроллер"),
 Так же помечаем класс аннотацией @EnableWebMvc - данная аннотация равносильна <mvc:annotation-driven/> - что было в applicationContext.xml
 Затем остается реализовать бины которые отвечают за реализацию конфигурации в шаблонизаторе thymeleaf (Просто скопировать его)
XOXOXOOXOXOXOXOXOXOXOOXOXOXOXOOXOXOXOXOXOXOXOOX

Что бы создать класс контроллер!
-Используем аннотацию @Controller над классом
-данная аннотация помечает класс - контроллер
-Наследуется от аннотации @Component
-Поэтому, @ComponentScan работает с @Controller так же, как и и просто с @Component
-@Controller - тот же @Component, но с дополнительными возможностями!
-------------------------------
Методы контроллера!
-Внутри контроллера может быть несколько методов
-Обычно(Но не всегда), каждый метод соответствует одному URL'у
-Обічно(Но не всегла), методы возвращают строку(String) - название представления, которое надо показать пользователю
-У метода может быть любое название
-------------------------------
- с помощью маппинга мы задаем адресс по которому будет доступен метод!
-маппинги связывают метод контроллера с тем адрессом который мы указали
-Всего есть 5 видов маппинга и каждый используется под определенные задачи, в зависимости от того, какой HTTP запрос (с каким HTTP методом) должен прийти в этот метод контроллера:
1)@GetMapping
2)@PostMapping
3)@PutMapping
4)DeleteMapping
5)PatchMapping
-------------------------------
@RequestMapping на классе!
- В этом случае URL адреса всех методов будут обязательно имет в себе /people - указанный юрл в аннотации @RequestMapping("/people")
-------------------------------
Параметры GET - запроса в Spring Framework!!!!
Можно получить двумя способами!
1. С помощью обьекта HttpServletRequest! //получаем полный доступ к HTTP - запросу
{
    @GetMapping("/hello")
    public String helloPage(HttpServletRequest request){
        String name = request.getParameter("name");
        //Работаем с пришедшим от пользователся параметром

       return "first/hello";
    }
}
//Так же, при использовании @RequestMapping - мы должны либо сразу в ссылке указывать параметры, либо в аннотации добавить параметр value = "name" request = false; иначе вылетит ошибка.
 2. С помощью аннотации @RequestMapping // Если нужны только параметры запроса, тогла используем данный способ, он короче и читабильней
{
    @GetMapping("/hello")
    public String helloPage(@RequestParam("name") String name){ //где "name" - это ключ параметра, а String name - это тип переменной
        //Работаем с пришедшим от пользователся параметром

        return "first/hello";
    }
}
XOXOXOOXOXOXOXOXOXOXOOXOXOXOXOOXOXOXOXOXOXOXOOX
Модель (Model) - Контейнер для хранения данных нашего приложения.
Для получения доступа к модели контроллера, пишем в параметрах просто Model - и спринг автоматически внедряет этот обьект необходимый в метод контроллера, уже внутри этого метода контроллера мы можем обратится к обьекту и использовать его!
@GetMapping("/hello")
public String helloPage(Model model){
    model.addAttribute("key", "Some value");

    return "first/hello";
}
===============================================
Что бы передать все с модели в представление, мы должны использовать тег th:
<p th:text="${message}"> </p> - таймлиф увидит код, обратится к модели, получит значение по ключу "message" и вставит текст в это пространство!
XOXOXOOXOXOXOXOXOXOXOOXOXOXOXOOXOXOXOXOXOXOXOOX
CRUD - Стандартная классификация функций по манипуляции данными.
Четыре базовые функции, используемые при работе с базами данных:
-CREATE
-READ
-UPDATE
-DELETE
CRUD приложение - это приложение, которое позволяет добавлять, читать, обновлять и удалять данные!
Оно общается с БД и дает запрос на CREATE, UPDATE, DELETE, в свою очередь БД возвращает нам READ!
Чаще всего CRUD приложения являются Web-приложения. То есть, доступ к БД предоставляется через протокол http!
-По сути, какой то клиент совершает http запросы к нашему CRUD приложению которое работает на веб сервере, это GET запросы для получения данных, это POST запрос на добавления данных, PATCH запрос на обновление каких то данных, DELETE запрос на удаление данных!
Все это попадает на CRUD приложение и уже оно общается  с БД.
-Почему именно такие урлы и такие методы? (Картинка в сохраненках) - потому что это все описывается стандартом который называется REST
-REST - это паттерн проектирования web-приложений!
-REST - описывает то, как посредством протокола http должен взаимодействовать клиент с сервером!
-Все взаимодействие с сервером сводится к 4 операциям - получение данных, добавление новых данных, изменение существующих данных, удаление данных!
-Для каждой из 4 операций исользуется свой HTTP метод - GET, POST, PATCH, DELETE.

REST vs CRUD!
CRUD - четыре базовые функции, используемые при работе с базами данных.

REST - паттерн проектирования web-приложений. Описывает, как по протоколу HTTP взаимодействовать с сервером для чтения, добавления, удаления данных.
Описывает, какие Урлы, HTTP методы использовать(но не только это)
==================================================
Паттерн DAO (Data Access Object) - отдельный класс занимается взаимодействием с БД.
-Мы хотим вынести логику взаимодействия с БД из самой модели в отдельный класс. Паттер проектирования, когда отдельный класс занимается взаимодействием с БД
для конкретной сущности называется DAO!
КАК ЭТО ВСЕ ВЫГЛЯДИТ!
-Мы не будет иметь никакой логи по взаимодействию с данными в нашей модели, у нас будет отдельный класс ДАО - который будет инкапсулировать всю работу и всю логику работы с БД
для какой-то данной модели. В классе ДАО будут какие то методы, мы их будем вызывать и соответсвтенно этот ДАО будет обращатся к БД и будет либо читать данные с базы, либо создавать,обновлять, удалять!
-обычно в ДАО классах пишется SQL код - для работы с БД.
P.s. - Есть другой паттер взаимодействия с БД - репозиторий. Его мы будем изучать, когда дойдем до Hibernate и Spring Вфеф JPA. этот паттерн предоставляет большую абстракцию над БД, чем DAO.
XOXOXOOXOXOXOXOXOXOXOOXOXOXOXOOXOXOXOXOXOXOXOOX
В HTML5 есть всего 2 основных запроса - GET & POST.
-Что бы решить данную проблему, мы в теле формы html указываем как метод пост, но в скрытом поле _method указывается желаемый HTTP метод.
-Thymeleaf берет это на себя.
-Как это выглядит:
    <form method="post" action="/people/1">
        <input type="hidden" name="_method" value="patch"> - через данное скрытое поле thymeleaf и поймет что мы конкретно хотим использовать patch запрос.
        <label for="name">Enter name: </label>
        <input type="text" id="name" name="name" value="Tom">
        <br>
        <input type="submit" value="Update!">
    </form>

-На стороне спринг приложения чтение скрытого метода реализуется с помощью фильтра!
-Фильтр - обьект, который перехватывает все входящие HTTP запросы. В данном случае фильтр используется для того,
чтобы смотреть на значение поля _method в поступающих HTTP запросах(если это поле есть).

P.s. На этом уроке подключим фильтр вручную. КОгда перейдем на Spring Boot, это будет делаться с помощью одной строки в конфигурационном файле.
XOXOXOOXOXOXOXOXOXOXOOXOXOXOXOOXOXOXOXOXOXOXOOX
АННОТАЦИЯ @VALID (часть ее возможностей)
@Valid -
Для работы с валидатором нам нужно добавить еще одну зависимость в Pom файл - в maven repository -> Hibernate validator - берем файнал версию и добавляем в зависимости.
@NotEmpty - проверяет то, пустая ли строка, если да - выдает сообщение об ошибке!
@Size - диапазон строки который нас устраивает! @Size(min = 2, max = 30, message = "error") - если мы выйдем за одну из границ, то получим "message".
@Min - устанавливает минимальное значение для числового поля! @Min(value = 0, message = "error") - так мы указываем что хотим видеть числа только целые и пооложительные.
@Email - использует регулярные выражения и проверяет валидность мейла.

- Что бы информация с формы валидировалась, в контроллере, в функции где создается обьект и назначается ему значения, мы указываем аннотацию @Valid, если у нас какие то условия нарушаются - у нас появляется ошибка, эта ошибка помещается в отдельный обьект!
-Объект называется - BindingResult bindingResult - он должен идти весгда после той модели, которая валидируется!
-Затем в теле метода мы проверяем есть ли какие-то ошибки в нашем обьекте, if(bindingResult.hasError()) - это специальный метод, который проверяет наличие ошибок.
-Если в этой форме есть ошибки, то мы не идем дальше, а сразу возвращаем страницу с созданием человека!
P.S. мы проверяли валидность данных в методах, где была наша модель, тем самым передавая значение через контроллер, в модели проверялась валидность информации!


